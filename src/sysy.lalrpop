use crate::base::r#type::Type;
use crate::frontend::ast::*;
use crate::frontend::parse::*;
use crate::utils::{is, cast_deref};

// lalrpop 里的约定
grammar;

// 约束 lexer 的行为
match {
  // 跳过空白符和注释
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*[^\n\r]*[\n\r]*\*/" => {},
  // 剩下的情况采用默认方式处理
  _
}

// 定义 CompUnit, 其返回值类型为 String
// parser 在解析完成后的行为是返回 FuncDef 的值
pub CompUnit: Box<dyn Node> = {
  <global_objs: (GlobalObj)*> => {
    Box::new(
      Block {
        statements: {
          let mut vec = vec![];
          for obj in global_objs {
            if is::<DeclAggr>(&*obj) {
              let decl_aggr = cast_deref::<DeclAggr>(obj).unwrap();
              for decl in decl_aggr.decls.into_iter() {
                vec.push(decl);
              }
            } else {
              vec.push(obj);
            }
          }
          vec
        }
      }
    )
  }
};

GlobalObj: Box<dyn Node> = {
  <func_def: FuncDef> => func_def,
  <global_decl: Decl> => global_decl,
};

// 同上, 不解释
FuncDef: Box<dyn Node> = {
  <b_type: BType> <ident: Ident> "(" <func_fparams: FuncFParams> ")" <block: Block> => {
    // construct FuncDef struct, using shorthand <> to pass all named fields
    Box::new(
      Function { 
        name: ident,
        params: func_fparams,
        body: block,
        return_type: b_type,
      }
    )
  },
  // case with no parameters
  <b_type: BType> <ident: Ident> "(" ")" <block: Block> => {
    Box::new(
      Function { 
        name: ident,
        params: vec![],
        body: block,
        return_type: b_type,
      }
    )
  },
  "void" <ident: Ident> "(" <func_fparams: FuncFParams> ")" <block: Block> => {
    Box::new(
      Function { 
        name: ident,
        params: func_fparams,
        body: block,
        return_type: Type::Void,
      }
    )
  },
  "void" <ident: Ident> "(" ")" <block: Block> => {
    Box::new(
      Function { 
        name: ident,
        params: vec![],
        body: block,
        return_type: Type::Void,
      }
    )
  },
};

FuncFParams: Vec<(String, Type)> = {
  <first_param: FuncFParam> <other_params: ("," FuncFParam)*> => {
    let mut param_list = vec![first_param];
    for (_, other_param) in other_params {
      param_list.push(other_param);
    }
    param_list
  }
};

FuncFParam: (String, Type) = {
  <param_type: BType> <ident: Ident> => (ident, param_type),
  <param_type: BType> <ident: Ident> <first_const_exp: ("[" "]")> <other_const_exps: ("[" ConstExp "]")*> => {
    let arr_type = Type::Pointer {
      base: Box::new(Type::Array {
        base: Box::new(param_type),
        dims: other_const_exps.into_iter().map(|(_, exp, _)| {
          // we only need the size info here, so we can assume the ConstExp is IntConst
          if let Some(int_node) = exp.as_any().downcast_ref::<Int>() {
            int_node.0 as u32
          } else {
            panic!("Array size must be a constant integer: {:?}", exp);
          }
        }).collect::<Vec<u32>>(),
      }),
    };
    (ident, arr_type)
  }
};

FuncType: Type = {
  "void" => Type::Void,
  <b_type: BType> => b_type,
};

BType: Type = {
  "int" => Type::Int,
  "float" => Type::Float,
};

Block: Box<dyn Node> = "{" <block_items: (BlockItem)*> "}" => Box::new(Block { statements: {
  let mut vec = vec![];
  for item in block_items {
    if is::<DeclAggr>(&*item) {
      let decl_aggr = cast_deref::<DeclAggr>(item).unwrap();
      for decl in decl_aggr.decls.into_iter() {
        vec.push(decl);
      }
    } else {
      vec.push(item);
    }
  }
  vec
}});

BlockItem: Box<dyn Node> = {
  <stmt: Stmt> => stmt,
  <decl: Decl> => decl,
};

Stmt: Box<dyn Node> = {
  <open_stmt: OpenStmt> => open_stmt,
  <close_stmt: CloseStmt> => close_stmt,
}

CloseStmt: Box<dyn Node> = {
  <simple_stmt: SimpleStmt> => simple_stmt,
  "if" "(" <condition: Exp> ")" <then_stmt: CloseStmt> "else" <else_stmt: CloseStmt> => Box::new(If {
      condition: condition,
      then_block: then_stmt,
      else_block: Some(else_stmt),
  }),
  "while" "(" <condition: Exp> ")" <body_stmt: CloseStmt> => Box::new(While {
      condition: condition,
      body: body_stmt,
  }),
};

OpenStmt: Box<dyn Node> = {
  "if" "(" <condition: Exp> ")" <then_stmt: CloseStmt> "else" <else_stmt: OpenStmt> => Box::new(If {
      condition: condition,
      then_block: then_stmt,
      else_block: Some(else_stmt),
  }),
  "if" "(" <condition: Exp> ")" <then_stmt: Stmt> => Box::new(If {
      condition: condition,
      then_block: then_stmt,
      else_block: None,
  }),
  "while" "(" <condition: Exp> ")" <body_stmt: OpenStmt> => Box::new(While {
      condition: condition,
      body: body_stmt,
  }),
};

SimpleStmt: Box<dyn Node> = {
  <l_val: LVal> "=" <exp: Exp> ";" => Box::new(Assign { lhs: l_val, rhs: exp }),
  <block: Block> => block,
  // return statement should have higher priority that RawExp.
  "return" <exp: Exp> ";" => Box::new(Return(Some(exp))),
  "return" ";" => Box::new(Return(None)),
  "break" ";" => Box::new(Break()),
  "continue" ";" => Box::new(Continue()),
  <exp: Exp> ";" => exp,
  ";" => Box::new(Empty()),
};

LVal: Box<dyn Node> = {
  <ident: Ident> <exps: ("[" Exp "]")*> => {
    // Dispatch VarAccess and ArrayAccess
    if exps.is_empty() {
      Box::new(VarAccess {
        name: ident,
        typ: Type::Void,
      })
    } else {
      Box::new(ArrayAccess {
        name: ident,
        indices: exps.into_iter().map(|(_, exp, _)| exp).collect(),
        typ: Type::Void,
      })
    }
  },
};

Decl: Box<dyn Node> = {
  <const_decl: ConstDecl> => const_decl,
  <var_decl: VarDecl> => var_decl,
}

ConstDecl: Box<dyn Node> = {
  "const" <b_type: BType> <const_def: ConstDef> <other_const_defs: ("," ConstDef)*> ";" => {
    let mut const_defs = vec![const_def];
    for (_, def) in other_const_defs {
      const_defs.push(def);
    }
    Box::new(
      DeclAggr {
        decls: canonicalize(
          RawDecl {
            typ: b_type,
            mutable: false,
            raw_decls: const_defs.into_iter().collect(),
          }
        ),
      }
    )
  }
}

ConstDef: RawDef = {
  <ident: Ident> <const_exps: ("[" ConstExp "]")*> "=" <const_init_val: ConstInitVal> => {
    // if const_exps is empty, then it's a scalar, we directly construct a VarDecl
    RawDef {
      ident,
      const_exps: const_exps.into_iter().map(|(_, exp, _)| 
        if let Some(int_node) = exp.as_any().downcast_ref::<Int>() {
          int_node.0 as u32
        } else {
          panic!("Array size must be a constant integer: {:?}", exp);
        }
      ).collect(),
      init_val: Some(const_init_val),
    }
  }
};

ConstInitVal: Box<dyn Node> = {
  <const_exp: ConstExp> => const_exp,
  "{" "}" => Box::new(ArrayInitVal { init_vals: vec![] }),
  "{" <first_init_val: ConstInitVal> <other_init_vals: ("," ConstInitVal)*> "}" => {
    let mut init_vals = vec![first_init_val];
    for (_, val) in other_init_vals {
      init_vals.push(val);
    }
    Box::new(ArrayInitVal { init_vals })
  }
};

ConstExp: Box<dyn Node> = {
  <exp: Exp> => {
    // do constant folding here
    fold(&exp)
  },
}

VarDecl: Box<dyn Node> = {
  <b_type: BType> <var_def: VarDef> <other_var_defs: ("," VarDef)*> ";" => {
    let mut var_defs = vec![var_def];
    for (_, def) in other_var_defs {
      var_defs.push(def);
    }

    Box::new(
      DeclAggr {
        decls: canonicalize(
          RawDecl {
            typ: b_type,
            mutable: true,
            raw_decls: var_defs.into_iter().collect(),
          }
        ),
      }
    )
  }
}

VarDef: RawDef = {
  <ident: Ident> <const_exps: ("[" ConstExp "]")*> "=" <init_val: InitVal> => RawDef {
    ident, 
    const_exps: const_exps.into_iter().map(|(_, exp, _)| {
      if let Some(int_node) = exp.as_any().downcast_ref::<Int>() {
        int_node.0 as u32
      } else {
        panic!("Array size must be a constant integer: {:?}", exp);
      }
    }).collect(), 
    init_val: Some(init_val),
  },
  <ident: Ident> <const_exps: ("[" ConstExp "]")*> => RawDef { 
    ident, 
    const_exps: const_exps.into_iter().map(|(_, exp, _)| {
      if let Some(int_node) = exp.as_any().downcast_ref::<Int>() {
        int_node.0 as u32
      } else {
        panic!("Array size must be a constant integer: {:?}", exp);
      }
    }).collect(), 
    init_val: None,
  },
};

InitVal: Box<dyn Node> = {
  <exp: Exp> => exp,
  "{" "}" => Box::new(ArrayInitVal { init_vals: vec![] }),
  "{" <first_init_val: InitVal> <other_init_vals: ("," InitVal)*> "}" => {
    let mut init_vals = vec![first_init_val];
    for (_, val) in other_init_vals {
      init_vals.push(val);
    }
    Box::new(ArrayInitVal { init_vals })
  }
};

// The priority of MulExp is higher than AddExp, so we should parse AddExp first, 
// which makes MulExp processed before AddExp in stmt_parser.
Exp: Box<dyn Node> = { 
  <lor_exp: LOrExp> => lor_exp,
};

// the match items in the block must follow the priority strictly
LOrExp: Box<dyn Node> = {
  <lor_exp: LOrExp> <lor_op: LOrOp> <land_exp: LAndExp> => Box::new(
    BinaryOp { 
      typ: Type::Void,
      lhs: lor_exp,
      op: lor_op,
      rhs: land_exp,
    }
  ),
  <land_exp: LAndExp> => land_exp,
};

LAndExp: Box<dyn Node> = {
  <land_exp: LAndExp> <land_op: LAndOp> <eq_exp: EqExp> => Box::new(
    BinaryOp { 
      typ: Type::Void,
      lhs: land_exp, 
      op: land_op, 
      rhs: eq_exp 
    }
  ),
  <eq_exp: EqExp> => eq_exp,
};

EqExp: Box<dyn Node> = {
  <eq_exp: EqExp> <eq_op: EqOp> <rel_exp: RelExp> => Box::new(
    BinaryOp { 
      typ: Type::Void,
      lhs: eq_exp, 
      op: eq_op, 
      rhs: rel_exp 
    }
  ),
  <rel_exp: RelExp> => rel_exp,
};

RelExp: Box<dyn Node> = {
  <rel_exp: RelExp> <rel_op: RelOp> <add_exp: AddExp> => Box::new(
    BinaryOp { 
      typ: Type::Void,
      lhs: rel_exp, 
      op: rel_op, 
      rhs: add_exp 
    }
  ),
  <add_exp: AddExp> => add_exp,
};

UnaryExp: Box<dyn Node> = {
  <unary_op: UnaryOp> <unary_exp: UnaryExp> => Box::new(
    UnaryOp { 
      typ: Type::Void,
      op: unary_op, 
      operand: unary_exp 
    }
  ),
  // function calling
  <ident: Ident> "(" <arg: Exp> <other_args: ("," Exp)*> ")" => Box::new(
    Call {
      typ: Type::Void,
      func_name: ident,
      args: {
        let mut args_vec = vec![arg];
        for (_, other_arg) in other_args {
          args_vec.push(other_arg);
        }
        args_vec
      },
    }
  ),
  <ident: Ident> "(" ")" => Box::new(
    Call {
      typ: Type::Void,
      func_name: ident,
      args: vec![],
    }
  ),
  <primary_exp: PrimaryExp> => primary_exp,
};

AddExp: Box<dyn Node> = {
  <add_exp: AddExp> <add_op: AddOp> <mul_exp: MulExp> => Box::new(
    BinaryOp { 
      typ: Type::Void,
      lhs: add_exp, 
      op: add_op, 
      rhs: mul_exp
    }
  ),
  <mul_exp: MulExp> => mul_exp,
};

MulExp: Box<dyn Node> = {
  <mul_exp: MulExp> <mul_op: MulOp> <unary_exp: UnaryExp> => Box::new(
    BinaryOp { 
      typ: Type::Void,
      lhs: mul_exp, 
      op: mul_op, 
      rhs: unary_exp 
    }
  ),
  <unary_exp: UnaryExp> => unary_exp,
};

PrimaryExp: Box<dyn Node> = {
  "(" <exp: Exp> ")" => exp,
  <l_val: LVal> => l_val,
  <num: Number> => num,
};

LOrOp: Op = {
  "||" => Op::Or,
};

LAndOp: Op = {
  "&&" => Op::And,
};

EqOp: Op = {
  "==" => Op::Eq,
  "!=" => Op::Ne,
};

RelOp: Op = {
  "<" => Op::Lt,
  "<=" => Op::Le,
  ">" => Op::Gt,
  ">=" => Op::Ge,
};

UnaryOp: Op = {
  r"\+" => Op::Plus,
  r"-" => Op::Minus,
  r"!" => Op::Not,
};

MulOp: Op = {
  r"\*" => Op::Mul,
  r"/" => Op::Div,
  r"%" => Op::Mod,
};

AddOp: Op = {
  r"\+" => Op::Add,
  r"-" => Op::Sub,
};

Number: Box<dyn Node> = {
  <int: IntConst> => Literal::Int(int),
  <float: FloatConst> => Literal::Float(float),
}

Ident: String = <s: r"[_a-zA-Z][_a-zA-Z0-9]*"> => {
  s.to_string()
};

IntConst: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
};

FloatConst: f32 = {
  r"[+-]?(?:(?:[0-9]*\.[0-9]+|[0-9]+\.)(?:[eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+)" => str::parse::<f32>(&<>).unwrap(),
};
